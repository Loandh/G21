import processing.video.*;
import oscP5.*;
import netP5.*;

Capture cam;
OscP5 oscP5;
NetAddress wekinator;

float blueX = 0, blueY = 0;
float greenX = 0, greenY = 0;
float ledX = 0, ledY = 0;

float lastBlueX = 0, lastBlueY = 0;
float lastGreenX = 0, lastGreenY = 0;
float lastLedX = 0, lastLedY = 0;

boolean blueDetected = false;
boolean greenDetected = false;
boolean ledDetected = false;

// HSV thresholds
float blueHueMin = 160, blueHueMax = 210;
float greenHueMin = 85, greenHueMax = 140;
float satMin = 80;
float valMin = 40;

// Movement detection
float movementThreshold = 0.01;     // ignore jitter below this
int stillTimeThreshold = 500;       // ms before considering "still"
int lastMoveTime = 0;
boolean messageSent = false;

// Always send update every few seconds even if nothing moves
int periodicSendInterval = 2000;   // ms
int lastPeriodicSend = 0;

void setup() {
  size(640, 480);
  String[] cameras = Capture.list();
  if (cameras == null || cameras.length == 0) {
    println("No cameras found!");
    exit();
  }

  println("Available cameras:");
  for (int i = 0; i < cameras.length; i++) println(i + ": " + cameras[i]);

  int camIndex = 1; // adjust camera index
  if (camIndex < 0 || camIndex >= cameras.length) camIndex = 0;
  cam = new Capture(this, cameras[camIndex]);
  cam.start();

  oscP5 = new OscP5(this, 12000);
  wekinator = new NetAddress("127.0.0.1", 6448);

  lastBlueX = lastBlueY = lastGreenX = lastGreenY = lastLedX = lastLedY = 0;
  lastMoveTime = millis();
  lastPeriodicSend = millis();
}

void draw() {
  if (cam.available()) cam.read();
  image(cam, 0, 0);

  // --- Track all colors ---
  PVector bluePos = trackColorHSV(blueHueMin, blueHueMax);
  PVector greenPos = trackColorHSV(greenHueMin, greenHueMax);
  PVector ledPos = trackBrightestSpot();

  // --- Update positions ---
  updateBallPosition("blue", bluePos);
  updateBallPosition("green", greenPos);
  updateBallPosition("led", ledPos);

  // --- Movement detection ---
  float blueMove = dist(blueX, blueY, lastBlueX, lastBlueY);
  float greenMove = dist(greenX, greenY, lastGreenX, lastGreenY);
  float ledMove = dist(ledX, ledY, lastLedX, lastLedY);

  boolean isMoving = (blueMove > movementThreshold ||
                      greenMove > movementThreshold ||
                      ledMove > movementThreshold);

  if (isMoving) {
    lastMoveTime = millis();
    messageSent = false;
  }

  // --- Send message when still or periodically ---
  int now = millis();
  if ((now - lastMoveTime > stillTimeThreshold && !messageSent) ||
      (now - lastPeriodicSend > periodicSendInterval)) {

    sendToWekinator();
    messageSent = true;
    lastPeriodicSend = now;
  }

  // --- Debug info ---
  fill(255);
  textSize(14);
  text("Blue detected: " + blueDetected, 10, height - 80);
  text("Green detected: " + greenDetected, 10, height - 60);
  text("LED detected: " + ledDetected, 10, height - 40);

  text("Blue (x,y): " + nf(blueX, 1, 2) + ", " + nf(blueY, 1, 2), 10, height - 20);
  text("Green (x,y): " + nf(greenX, 1, 2) + ", " + nf(greenY, 1, 2), 220, height - 20);
  text("LED (x,y): " + nf(ledX, 1, 2) + ", " + nf(ledY, 1, 2), 430, height - 20);

  text("Moving: " + isMoving, 10, 20);
  if (messageSent) text("OSC SENT (balls still or periodic)", 10, 40);
}

// ---------------------------
// Update positions
// ---------------------------
void updateBallPosition(String colorName, PVector pos) {
  if (colorName == null) return;

  if (colorName.equals("blue")) {
    lastBlueX = blueX;
    lastBlueY = blueY;
    if (pos != null) {
      blueDetected = true;
      fill(0, 0, 255);
      ellipse(pos.x, pos.y, 25, 25);
      blueX = pos.x / width;
      blueY = pos.y / height;
    } else {
      blueDetected = false;
      blueX = blueY = 0;
    }
    return;
  }

  if (colorName.equals("green")) {
    lastGreenX = greenX;
    lastGreenY = greenY;
    if (pos != null) {
      greenDetected = true;
      fill(0, 255, 0);
      ellipse(pos.x, pos.y, 25, 25);
      greenX = pos.x / width;
      greenY = pos.y / height;
    } else {
      greenDetected = false;
      greenX = greenY = 0;
    }
    return;
  }

  if (colorName.equals("led")) {
    lastLedX = ledX;
    lastLedY = ledY;
    if (pos != null) {
      ledDetected = true;
      fill(255, 255, 0);
      ellipse(pos.x, pos.y, 30, 30);
      ledX = pos.x / width;
      ledY = pos.y / height;
    } else {
      ledDetected = false;
      ledX = ledY = 0;
    }
    return;
  }
}

// ---------------------------
// Send OSC to Wekinator
// ---------------------------
void sendToWekinator() {
  OscMessage msg = new OscMessage("/wek/inputs");
  msg.add(blueX);
  msg.add(blueY);
  msg.add(greenX);
  msg.add(greenY);
  msg.add(ledX);
  msg.add(ledY);
  oscP5.send(msg, wekinator);
  println("ðŸŸ¢ Sent OSC to Wekinator (balls still or periodic)");
}

// ---------------------------
// Track blue/green in HSV
// ---------------------------
PVector trackColorHSV(float hueMin, float hueMax) {
  cam.loadPixels();
  float avgX = 0, avgY = 0;
  int count = 0;

  for (int i = 0; i < cam.pixels.length; i++) {
    color c = cam.pixels[i];
    float h = hue(c);
    float s = saturation(c);
    float v = brightness(c);

    boolean match = (h >= hueMin && h <= hueMax);
    if (match && s > satMin && v > valMin) {
      avgX += i % cam.width;
      avgY += i / cam.width;
      count++;
    }
  }

  if (count > 0) return new PVector(avgX / count, avgY / count);
  else return null;
}

// ---------------------------
// Detect brightest spot (LED)
// ---------------------------
PVector trackBrightestSpot() {
  cam.loadPixels();

  float maxBrightness = 0;
  int brightestIndex = -1;

  for (int i = 0; i < cam.pixels.length; i++) {
    float v = brightness(cam.pixels[i]);
    if (v > maxBrightness) {
      maxBrightness = v;
      brightestIndex = i;
    }
  }

  if (brightestIndex == -1 || maxBrightness < 80) return null;

  float x = brightestIndex % cam.width;
  float y = brightestIndex / cam.width;
  return new PVector(x, y);
}
