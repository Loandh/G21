import processing.video.*;
import oscP5.*;
import netP5.*;

Capture cam;
OscP5 oscP5;
NetAddress wekinator;

float blueX = 0, blueY = 0;
float greenX = 0, greenY = 0;
float redX = 0, redY = 0;


boolean blueDetected = false;
boolean greenDetected = false;
boolean redDetected = false;

// HSV thresholds (adjust as needed)
float blueHueMin = 160, blueHueMax = 210;

float greenHueMin = 85, greenHueMax = 140;

float redHueMin1 = 0, redHueMax1 = 15;
float redHueMin2 = 230, redHueMax2 = 255;

float satMin = 80;   // filter out gray
float valMin = 40;   // filter out dark pixels

void setup() {
   size(640, 480);

  // List all available cameras
  String[] cameras = Capture.list();

  if (cameras == null || cameras.length == 0) {
    println("No cameras found!");
    exit();
  }

  println("Available cameras:");
  for (int i = 0; i < cameras.length; i++) {
    println(i + ": " + cameras[i]);
  }

  //Pick your external webcam manually by its index (check console)
  int camIndex = 1;  // <-- Change this after you see the printed list

  // Initialize the chosen camera
  cam = new Capture(this, cameras[camIndex]);
  cam.start();

  oscP5 = new OscP5(this, 12000);
  wekinator = new NetAddress("127.0.0.1", 6448);
}

void draw() {
  if (cam.available()) cam.read();
  image(cam, 0, 0);

  PVector bluePos = trackColorHSV(blueHueMin, blueHueMax);
  PVector greenPos = trackColorHSV(greenHueMin, greenHueMax);
  PVector redPos = trackColorHSV(redHueMin1, redHueMax1);

  if (bluePos != null) {
    blueDetected = true;
    fill(0, 0, 255);
    noStroke();
    ellipse(bluePos.x, bluePos.y, 25, 25);
    blueX = bluePos.x / width;
    blueY = bluePos.y / height;
  } else {
    blueDetected = false;
    blueX = 0;
    blueY = 0;
  }

  if (greenPos != null) {
    greenDetected = true;
    fill(0, 255, 0);
    noStroke();
    ellipse(greenPos.x, greenPos.y, 25, 25);
    greenX = greenPos.x / width;
    greenY = greenPos.y / height;
  } else {
    greenDetected = false;
    greenX = 0;
    greenY = 0;
  }
  
  if (redPos != null) {
    redDetected = true;
    fill(255, 0, 0);
    noStroke();
    ellipse(redPos.x, redPos.y, 25, 25);
    redX = redPos.x / width;
    redY = redPos.y / height;
  } else {
    redDetected = false;
    redX = 0;
    redY = 0;
  }

  // --- Send OSC message to Wekinator ---
  OscMessage msg = new OscMessage("/wek/inputs");
  msg.add(blueX);
  msg.add(blueY);
  //msg.add(blueDetected ? 1 : 0);
  msg.add(greenX);
  msg.add(greenY);
  //msg.add(greenDetected ? 1 : 0);
  msg.add(redX);
  msg.add(redY);
 // msg.add(redDetected ? 1 : 0);
  oscP5.send(msg, wekinator);
  

  // --- Debug info ---
  fill(255);
  textSize(14);
  text("Blue detected: " + blueDetected, 10, height - 60);
  text("Green detected: " + greenDetected, 10, height - 40);
  text("Red detected: " + redDetected, 10, height);
  
  text("Blue (x, y): " + nf(blueX, 1, 2) + ", " + nf(blueY, 1, 2), 10, height - 20);
  text("Green (x, y): " + nf(greenX, 1, 2) + ", " + nf(greenY, 1, 2), 10, height - 5);
  text("Red (x,y): " + nf(redX, 1, 2) + ", " + nf(redY, 1, 2), 10, height);
}

// --- HSV tracking function ---
PVector trackColorHSV(float hueMin, float hueMax) {
  cam.loadPixels();
  float avgX = 0, avgY = 0;
  int count = 0;

  for (int i = 0; i < cam.pixels.length; i++) {
    color c = cam.pixels[i];
    float h = hue(c);
    float s = saturation(c);
    float v = brightness(c);

    if (hueMin < hueMax) {
      if (h >= hueMin && h <= hueMax && s > satMin && v > valMin) {
        avgX += i % cam.width;
        avgY += i / cam.width;
        count++;
      }
    } else {
      // handle hue wrap-around (e.g., red)
      if ((h >= hueMin || h <= hueMax) && s > satMin && v > valMin) {
        avgX += i % cam.width;
        avgY += i / cam.width;
        count++;
      }
    }
  }

  if (count > 0) {
    avgX /= count;
    avgY /= count;
    return new PVector(avgX, avgY);
  } else {
    return null;
  }
}
