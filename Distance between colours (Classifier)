// needs tweaking for RGB ranges
// very tempermental depending on lighting 
// Wekinator: inputs = 5 , outputs = 2 (2 classes) - classifier 

import processing.video.*;
import oscP5.*;
import netP5.*;

Capture cam;
OscP5 oscP5;
NetAddress wek;

// ----- Display (pixelation) -----
int viewW = 640, viewH = 480; // window size
int videoW = 640, videoH = 480; // capture size
int videoScale = 8; // pixel block size for display only

// ----- Detection / smoothing -----
PVector greenC = new PVector(-1,-1);
PVector pinkC  = new PVector(-1,-1);
PVector greenSm = new PVector(-1,-1);
PVector pinkSm  = new PVector(-1,-1);
float distNorm = 0, distNormPrev = 0, dDist = 0;
boolean haveGreen=false, havePink=false;
float emaAlpha = 0.35; // smoothing (0..1). Higher = snappier

void settings() {
  size(viewW, viewH);
}

void setup() {
  cam = new Capture(this, videoW, videoH);
  cam.start();

  oscP5 = new OscP5(this, 12000);           // local port (unused for send)
  wek   = new NetAddress("127.0.0.1", 6448); // Wekinator default input

  frameRate(30);
}

void captureEvent(Capture c){ c.read(); }

void draw() {
  background(0);
  if (cam.available()) cam.read();

  // --- 1) Pixelated display (for looks only) ---
  drawPixelated(cam, videoScale);

  // --- 2) Detect centroids (HSV thresholding) ---
  haveGreen = findCentroidHSV(cam, /*hLo*/45, /*hHi*/90, /*s*/0.35, /*v*/0.15, greenC);
  havePink  = findCentroidHSV(cam, 280, 360, 0.35, 0.15, pinkC);

  // --- 3) Smooth the centroids (EMA) ---
  if (haveGreen) ema(greenSm, greenC, emaAlpha);
  if (havePink)  ema(pinkSm,  pinkC,  emaAlpha);

  // Draw markers (on the pixelated view)
  noStroke();
  if (haveGreen) { fill(0,255,255); ellipse(greenSm.x, greenSm.y, 12,12); }
  if (havePink)  { fill(255,120,120); ellipse(pinkSm.x, pinkSm.y, 12,12); }
  if (haveGreen && havePink) {
    stroke(255); noFill(); line(greenSm.x, greenSm.y, pinkSm.x, pinkSm.y);
  }

  // --- 4) Build features & send to Wekinator ---
  float gx=0, gy=0, px=0, py=0; int hasG=0, hasP=0;
  if (haveGreen) {
    gx = greenSm.x / cam.width;
    gy = greenSm.y / cam.height;
    hasG = 1;
  }
  if (havePink) {
    px = pinkSm.x / cam.width;
    py = pinkSm.y / cam.height;
    hasP = 1;
  }

  float diag = sqrt(cam.width*cam.width + cam.height*cam.height);
  if (haveGreen && havePink) {
    distNormPrev = distNorm;
    distNorm = dist(greenSm.x, greenSm.y, pinkSm.x, pinkSm.y) / diag;
    dDist = distNorm - distNormPrev;
  } else {
    // keep values stable when a ball is missing
    distNorm = 0;
    dDist = 0;
  }

  // Choose your feature set (keep it modest):
  // Option A (minimal): bx, by, rx, ry, distNorm
  // Option B (+temporal/robustness): bx, by, rx, ry, distNorm, dDist, hasB, hasR
  OscMessage m = new OscMessage("/wek/inputs");
  m.add(gx); m.add(gy); m.add(px); m.add(py); m.add(distNorm);
  // Uncomment if you want the extras too:
  // m.add(dDist); m.add((float)hasB); m.add((float)hasR);
  oscP5.send(m, wek);
}

// ---------- Helpers ----------

// Pixelated display from a full-res frame
void drawPixelated(PImage img, int block) {
  img.loadPixels();
  noStroke();
  for (int y = 0; y < img.height; y += block) {
    int base = y * img.width;
    for (int x = 0; x < img.width; x += block) {
      int idx = base + x;
      if (idx >= 0 && idx < img.pixels.length) {
        fill(img.pixels[idx]);
        rect(x, y, block, block);
      }
    }
  }
}

// Find centroid for a non-wrapping hue band (e.g., blue)
boolean findCentroidHSV(PImage img, float hLo, float hHi, float sMin, float vMin, PVector out) {
  img.loadPixels();
  float sx=0, sy=0; int n=0;
  for (int y=0; y<img.height; y++) {
    int base = y*img.width;
    for (int x=0; x<img.width; x++) {
      int c = img.pixels[base+x];
      float[] hsv = rgbToHsv(red(c), green(c), blue(c));
      if (hsv[0] >= hLo && hsv[0] <= hHi && hsv[1] > sMin && hsv[2] > vMin) {
        sx += x; sy += y; n++;
      }
    }
  }
  if (n < 40) return false; // ignore tiny/noisy blobs
  out.set(sx/n, sy/n);
  return true;
}

// Red hue wraps around 0Â°, so use two bands
boolean findCentroidHSV_Red(PImage img, float sMin, float vMin, PVector out) {
  img.loadPixels();
  float sx=0, sy=0; int n=0;
  for (int y=0; y<img.height; y++) {
    int base = y*img.width;
    for (int x=0; x<img.width; x++) {
      int c = img.pixels[base+x];
      float[] hsv = rgbToHsv(red(c), green(c), blue(c));
      boolean redBand = (hsv[0] <= 20 || hsv[0] >= 340);
      if (redBand && hsv[1] > sMin && hsv[2] > vMin) {
        sx += x; sy += y; n++;
      }
    }
  }
  if (n < 40) return false;
  out.set(sx/n, sy/n);
  return true;
}

// Simple exponential moving average
void ema(PVector sm, PVector cur, float a) {
  if (sm.x < 0 || sm.y < 0) { sm.set(cur); return; } // first time
  sm.x = a*cur.x + (1-a)*sm.x;
  sm.y = a*cur.y + (1-a)*sm.y;
}

// RGB -> HSV (h in degrees 0..360, s/v 0..1)
float[] rgbToHsv(float r, float g, float b) {
  r/=255; g/=255; b/=255;
  float maxv = max(r, max(g, b)), minv = min(r, min(g, b));
  float h=0, s, v=maxv, d=maxv-minv;
  s = (maxv==0)? 0 : d/maxv;
  if (d==0) h=0;
  else if (maxv==r) h = 60 * (((g-b)/d) % 6);
  else if (maxv==g) h = 60 * (((b-r)/d) + 2);
  else               h = 60 * (((r-g)/d) + 4);
  if (h < 0) h += 360;
  return new float[]{h, s, v};
}
